<?php
/**
 * EditHtmlApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * convertapi
 *
 * Convert API lets you effortlessly convert file formats and types.
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * EditHtmlApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class EditHtmlApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation editHtmlHtmlAppendHeading
     *
     * Append a Heading to an HTML Document
     *
     * @param  string $heading_text The text content to be used in the header. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  int $heading_size Optional: The heading size number. Default is 1. Accepts values between 1 and 6. (optional)
     * @param  string $css_style Optional: The CSS style for the heading. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlAppendHeading($heading_text, $input_file = null, $input_file_url = null, $heading_size = null, $css_style = null)
    {
        list($response) = $this->editHtmlHtmlAppendHeadingWithHttpInfo($heading_text, $input_file, $input_file_url, $heading_size, $css_style);
        return $response;
    }

    /**
     * Operation editHtmlHtmlAppendHeadingWithHttpInfo
     *
     * Append a Heading to an HTML Document
     *
     * @param  string $heading_text The text content to be used in the header. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  int $heading_size Optional: The heading size number. Default is 1. Accepts values between 1 and 6. (optional)
     * @param  string $css_style Optional: The CSS style for the heading. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlAppendHeadingWithHttpInfo($heading_text, $input_file = null, $input_file_url = null, $heading_size = null, $css_style = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendHeadingRequest($heading_text, $input_file, $input_file_url, $heading_size, $css_style);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlAppendHeadingAsync
     *
     * Append a Heading to an HTML Document
     *
     * @param  string $heading_text The text content to be used in the header. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  int $heading_size Optional: The heading size number. Default is 1. Accepts values between 1 and 6. (optional)
     * @param  string $css_style Optional: The CSS style for the heading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendHeadingAsync($heading_text, $input_file = null, $input_file_url = null, $heading_size = null, $css_style = null)
    {
        return $this->editHtmlHtmlAppendHeadingAsyncWithHttpInfo($heading_text, $input_file, $input_file_url, $heading_size, $css_style)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlAppendHeadingAsyncWithHttpInfo
     *
     * Append a Heading to an HTML Document
     *
     * @param  string $heading_text The text content to be used in the header. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  int $heading_size Optional: The heading size number. Default is 1. Accepts values between 1 and 6. (optional)
     * @param  string $css_style Optional: The CSS style for the heading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendHeadingAsyncWithHttpInfo($heading_text, $input_file = null, $input_file_url = null, $heading_size = null, $css_style = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendHeadingRequest($heading_text, $input_file, $input_file_url, $heading_size, $css_style);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlAppendHeading'
     *
     * @param  string $heading_text The text content to be used in the header. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  int $heading_size Optional: The heading size number. Default is 1. Accepts values between 1 and 6. (optional)
     * @param  string $css_style Optional: The CSS style for the heading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlAppendHeadingRequest($heading_text, $input_file = null, $input_file_url = null, $heading_size = null, $css_style = null)
    {
        // verify the required parameter 'heading_text' is set
        if ($heading_text === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $heading_text when calling editHtmlHtmlAppendHeading'
            );
        }

        $resourcePath = '/convert/edit/html/append/heading';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($heading_text !== null) {
            $headerParams['headingText'] = ObjectSerializer::toHeaderValue($heading_text);
        }
        // header params
        if ($heading_size !== null) {
            $headerParams['headingSize'] = ObjectSerializer::toHeaderValue($heading_size);
        }
        // header params
        if ($css_style !== null) {
            $headerParams['cssStyle'] = ObjectSerializer::toHeaderValue($css_style);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlAppendImageFromUrl
     *
     * Append an Image to an HTML Document from a URL
     *
     * @param  string $image_url The URL for the image. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlAppendImageFromUrl($image_url, $input_file = null, $input_file_url = null, $css_style = null)
    {
        list($response) = $this->editHtmlHtmlAppendImageFromUrlWithHttpInfo($image_url, $input_file, $input_file_url, $css_style);
        return $response;
    }

    /**
     * Operation editHtmlHtmlAppendImageFromUrlWithHttpInfo
     *
     * Append an Image to an HTML Document from a URL
     *
     * @param  string $image_url The URL for the image. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlAppendImageFromUrlWithHttpInfo($image_url, $input_file = null, $input_file_url = null, $css_style = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendImageFromUrlRequest($image_url, $input_file, $input_file_url, $css_style);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlAppendImageFromUrlAsync
     *
     * Append an Image to an HTML Document from a URL
     *
     * @param  string $image_url The URL for the image. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendImageFromUrlAsync($image_url, $input_file = null, $input_file_url = null, $css_style = null)
    {
        return $this->editHtmlHtmlAppendImageFromUrlAsyncWithHttpInfo($image_url, $input_file, $input_file_url, $css_style)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlAppendImageFromUrlAsyncWithHttpInfo
     *
     * Append an Image to an HTML Document from a URL
     *
     * @param  string $image_url The URL for the image. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendImageFromUrlAsyncWithHttpInfo($image_url, $input_file = null, $input_file_url = null, $css_style = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendImageFromUrlRequest($image_url, $input_file, $input_file_url, $css_style);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlAppendImageFromUrl'
     *
     * @param  string $image_url The URL for the image. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlAppendImageFromUrlRequest($image_url, $input_file = null, $input_file_url = null, $css_style = null)
    {
        // verify the required parameter 'image_url' is set
        if ($image_url === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_url when calling editHtmlHtmlAppendImageFromUrl'
            );
        }

        $resourcePath = '/convert/edit/html/append/image/from-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($image_url !== null) {
            $headerParams['imageUrl'] = ObjectSerializer::toHeaderValue($image_url);
        }
        // header params
        if ($css_style !== null) {
            $headerParams['cssStyle'] = ObjectSerializer::toHeaderValue($css_style);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlAppendImageInline
     *
     * Append a Base64 Inline Image to an HTML Document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  \SplFileObject $image_file Optional: Image file to be appended as base64 inline image. (optional)
     * @param  string $image_url Optional: Image URL to be appended as base64 inline image. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     * @param  string $image_extension Optional: The extension (JPG, PNG, GIF, etc.) of the image file. Recommended if uploading an imageFile directly, instead of using imageUrl. If no extension can be determined, will default to JPG. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlAppendImageInline($input_file = null, $input_file_url = null, $image_file = null, $image_url = null, $css_style = null, $image_extension = null)
    {
        list($response) = $this->editHtmlHtmlAppendImageInlineWithHttpInfo($input_file, $input_file_url, $image_file, $image_url, $css_style, $image_extension);
        return $response;
    }

    /**
     * Operation editHtmlHtmlAppendImageInlineWithHttpInfo
     *
     * Append a Base64 Inline Image to an HTML Document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  \SplFileObject $image_file Optional: Image file to be appended as base64 inline image. (optional)
     * @param  string $image_url Optional: Image URL to be appended as base64 inline image. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     * @param  string $image_extension Optional: The extension (JPG, PNG, GIF, etc.) of the image file. Recommended if uploading an imageFile directly, instead of using imageUrl. If no extension can be determined, will default to JPG. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlAppendImageInlineWithHttpInfo($input_file = null, $input_file_url = null, $image_file = null, $image_url = null, $css_style = null, $image_extension = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendImageInlineRequest($input_file, $input_file_url, $image_file, $image_url, $css_style, $image_extension);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlAppendImageInlineAsync
     *
     * Append a Base64 Inline Image to an HTML Document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  \SplFileObject $image_file Optional: Image file to be appended as base64 inline image. (optional)
     * @param  string $image_url Optional: Image URL to be appended as base64 inline image. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     * @param  string $image_extension Optional: The extension (JPG, PNG, GIF, etc.) of the image file. Recommended if uploading an imageFile directly, instead of using imageUrl. If no extension can be determined, will default to JPG. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendImageInlineAsync($input_file = null, $input_file_url = null, $image_file = null, $image_url = null, $css_style = null, $image_extension = null)
    {
        return $this->editHtmlHtmlAppendImageInlineAsyncWithHttpInfo($input_file, $input_file_url, $image_file, $image_url, $css_style, $image_extension)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlAppendImageInlineAsyncWithHttpInfo
     *
     * Append a Base64 Inline Image to an HTML Document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  \SplFileObject $image_file Optional: Image file to be appended as base64 inline image. (optional)
     * @param  string $image_url Optional: Image URL to be appended as base64 inline image. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     * @param  string $image_extension Optional: The extension (JPG, PNG, GIF, etc.) of the image file. Recommended if uploading an imageFile directly, instead of using imageUrl. If no extension can be determined, will default to JPG. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendImageInlineAsyncWithHttpInfo($input_file = null, $input_file_url = null, $image_file = null, $image_url = null, $css_style = null, $image_extension = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendImageInlineRequest($input_file, $input_file_url, $image_file, $image_url, $css_style, $image_extension);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlAppendImageInline'
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  \SplFileObject $image_file Optional: Image file to be appended as base64 inline image. (optional)
     * @param  string $image_url Optional: Image URL to be appended as base64 inline image. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     * @param  string $image_extension Optional: The extension (JPG, PNG, GIF, etc.) of the image file. Recommended if uploading an imageFile directly, instead of using imageUrl. If no extension can be determined, will default to JPG. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlAppendImageInlineRequest($input_file = null, $input_file_url = null, $image_file = null, $image_url = null, $css_style = null, $image_extension = null)
    {

        $resourcePath = '/convert/edit/html/append/image/inline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($image_url !== null) {
            $headerParams['imageUrl'] = ObjectSerializer::toHeaderValue($image_url);
        }
        // header params
        if ($css_style !== null) {
            $headerParams['cssStyle'] = ObjectSerializer::toHeaderValue($css_style);
        }
        // header params
        if ($image_extension !== null) {
            $headerParams['imageExtension'] = ObjectSerializer::toHeaderValue($image_extension);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // form params
        if ($image_file !== null) {
            $multipart = true;
            $formParams['imageFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($image_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlAppendParagraph
     *
     * Append a Paragraph to an HTML Document
     *
     * @param  string $paragraph_text The text content to be used in the paragraph. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: The CSS style for the paragraph. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlAppendParagraph($paragraph_text, $input_file = null, $input_file_url = null, $css_style = null)
    {
        list($response) = $this->editHtmlHtmlAppendParagraphWithHttpInfo($paragraph_text, $input_file, $input_file_url, $css_style);
        return $response;
    }

    /**
     * Operation editHtmlHtmlAppendParagraphWithHttpInfo
     *
     * Append a Paragraph to an HTML Document
     *
     * @param  string $paragraph_text The text content to be used in the paragraph. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: The CSS style for the paragraph. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlAppendParagraphWithHttpInfo($paragraph_text, $input_file = null, $input_file_url = null, $css_style = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendParagraphRequest($paragraph_text, $input_file, $input_file_url, $css_style);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlAppendParagraphAsync
     *
     * Append a Paragraph to an HTML Document
     *
     * @param  string $paragraph_text The text content to be used in the paragraph. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: The CSS style for the paragraph. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendParagraphAsync($paragraph_text, $input_file = null, $input_file_url = null, $css_style = null)
    {
        return $this->editHtmlHtmlAppendParagraphAsyncWithHttpInfo($paragraph_text, $input_file, $input_file_url, $css_style)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlAppendParagraphAsyncWithHttpInfo
     *
     * Append a Paragraph to an HTML Document
     *
     * @param  string $paragraph_text The text content to be used in the paragraph. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: The CSS style for the paragraph. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendParagraphAsyncWithHttpInfo($paragraph_text, $input_file = null, $input_file_url = null, $css_style = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendParagraphRequest($paragraph_text, $input_file, $input_file_url, $css_style);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlAppendParagraph'
     *
     * @param  string $paragraph_text The text content to be used in the paragraph. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: The CSS style for the paragraph. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlAppendParagraphRequest($paragraph_text, $input_file = null, $input_file_url = null, $css_style = null)
    {
        // verify the required parameter 'paragraph_text' is set
        if ($paragraph_text === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $paragraph_text when calling editHtmlHtmlAppendParagraph'
            );
        }

        $resourcePath = '/convert/edit/html/append/paragraph';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($paragraph_text !== null) {
            $headerParams['paragraphText'] = ObjectSerializer::toHeaderValue($paragraph_text);
        }
        // header params
        if ($css_style !== null) {
            $headerParams['cssStyle'] = ObjectSerializer::toHeaderValue($css_style);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlCreateBlankDocument
     *
     * Create a Blank HTML Document
     *
     * @param  string $title Optional: The title of the HTML document (optional)
     * @param  string $css_url Optional: A CSS style URL to be added to the document. (optional)
     * @param  string $css_inline Optional: An inline CSS style to be added to the document. (optional)
     * @param  string $javascript_url Optional: Javascript URL to be added to the document. (optional)
     * @param  string $javascript_inline Optional: Inline Javascript to be added to the document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlCreateBlankDocument($title = null, $css_url = null, $css_inline = null, $javascript_url = null, $javascript_inline = null)
    {
        list($response) = $this->editHtmlHtmlCreateBlankDocumentWithHttpInfo($title, $css_url, $css_inline, $javascript_url, $javascript_inline);
        return $response;
    }

    /**
     * Operation editHtmlHtmlCreateBlankDocumentWithHttpInfo
     *
     * Create a Blank HTML Document
     *
     * @param  string $title Optional: The title of the HTML document (optional)
     * @param  string $css_url Optional: A CSS style URL to be added to the document. (optional)
     * @param  string $css_inline Optional: An inline CSS style to be added to the document. (optional)
     * @param  string $javascript_url Optional: Javascript URL to be added to the document. (optional)
     * @param  string $javascript_inline Optional: Inline Javascript to be added to the document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlCreateBlankDocumentWithHttpInfo($title = null, $css_url = null, $css_inline = null, $javascript_url = null, $javascript_inline = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlCreateBlankDocumentRequest($title, $css_url, $css_inline, $javascript_url, $javascript_inline);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlCreateBlankDocumentAsync
     *
     * Create a Blank HTML Document
     *
     * @param  string $title Optional: The title of the HTML document (optional)
     * @param  string $css_url Optional: A CSS style URL to be added to the document. (optional)
     * @param  string $css_inline Optional: An inline CSS style to be added to the document. (optional)
     * @param  string $javascript_url Optional: Javascript URL to be added to the document. (optional)
     * @param  string $javascript_inline Optional: Inline Javascript to be added to the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlCreateBlankDocumentAsync($title = null, $css_url = null, $css_inline = null, $javascript_url = null, $javascript_inline = null)
    {
        return $this->editHtmlHtmlCreateBlankDocumentAsyncWithHttpInfo($title, $css_url, $css_inline, $javascript_url, $javascript_inline)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlCreateBlankDocumentAsyncWithHttpInfo
     *
     * Create a Blank HTML Document
     *
     * @param  string $title Optional: The title of the HTML document (optional)
     * @param  string $css_url Optional: A CSS style URL to be added to the document. (optional)
     * @param  string $css_inline Optional: An inline CSS style to be added to the document. (optional)
     * @param  string $javascript_url Optional: Javascript URL to be added to the document. (optional)
     * @param  string $javascript_inline Optional: Inline Javascript to be added to the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlCreateBlankDocumentAsyncWithHttpInfo($title = null, $css_url = null, $css_inline = null, $javascript_url = null, $javascript_inline = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlCreateBlankDocumentRequest($title, $css_url, $css_inline, $javascript_url, $javascript_inline);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlCreateBlankDocument'
     *
     * @param  string $title Optional: The title of the HTML document (optional)
     * @param  string $css_url Optional: A CSS style URL to be added to the document. (optional)
     * @param  string $css_inline Optional: An inline CSS style to be added to the document. (optional)
     * @param  string $javascript_url Optional: Javascript URL to be added to the document. (optional)
     * @param  string $javascript_inline Optional: Inline Javascript to be added to the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlCreateBlankDocumentRequest($title = null, $css_url = null, $css_inline = null, $javascript_url = null, $javascript_inline = null)
    {

        $resourcePath = '/convert/edit/html/create/blank';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($title !== null) {
            $headerParams['title'] = ObjectSerializer::toHeaderValue($title);
        }
        // header params
        if ($css_url !== null) {
            $headerParams['cssUrl'] = ObjectSerializer::toHeaderValue($css_url);
        }
        // header params
        if ($css_inline !== null) {
            $headerParams['cssInline'] = ObjectSerializer::toHeaderValue($css_inline);
        }
        // header params
        if ($javascript_url !== null) {
            $headerParams['javascriptUrl'] = ObjectSerializer::toHeaderValue($javascript_url);
        }
        // header params
        if ($javascript_inline !== null) {
            $headerParams['javascriptInline'] = ObjectSerializer::toHeaderValue($javascript_inline);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
