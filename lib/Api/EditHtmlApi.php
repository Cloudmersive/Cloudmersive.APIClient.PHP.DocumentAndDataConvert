<?php
/**
 * EditHtmlApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * convertapi
 *
 * Convert API lets you effortlessly convert file formats and types.
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * EditHtmlApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class EditHtmlApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation editHtmlHtmlAppendHeaderTag
     *
     * Append an HTML tag to the HEAD section of an HTML Document
     *
     * @param  string $html_tag The HTML tag to append. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlAppendHeaderTag($html_tag, $input_file = null, $input_file_url = null)
    {
        list($response) = $this->editHtmlHtmlAppendHeaderTagWithHttpInfo($html_tag, $input_file, $input_file_url);
        return $response;
    }

    /**
     * Operation editHtmlHtmlAppendHeaderTagWithHttpInfo
     *
     * Append an HTML tag to the HEAD section of an HTML Document
     *
     * @param  string $html_tag The HTML tag to append. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlAppendHeaderTagWithHttpInfo($html_tag, $input_file = null, $input_file_url = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendHeaderTagRequest($html_tag, $input_file, $input_file_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlAppendHeaderTagAsync
     *
     * Append an HTML tag to the HEAD section of an HTML Document
     *
     * @param  string $html_tag The HTML tag to append. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendHeaderTagAsync($html_tag, $input_file = null, $input_file_url = null)
    {
        return $this->editHtmlHtmlAppendHeaderTagAsyncWithHttpInfo($html_tag, $input_file, $input_file_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlAppendHeaderTagAsyncWithHttpInfo
     *
     * Append an HTML tag to the HEAD section of an HTML Document
     *
     * @param  string $html_tag The HTML tag to append. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendHeaderTagAsyncWithHttpInfo($html_tag, $input_file = null, $input_file_url = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendHeaderTagRequest($html_tag, $input_file, $input_file_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlAppendHeaderTag'
     *
     * @param  string $html_tag The HTML tag to append. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlAppendHeaderTagRequest($html_tag, $input_file = null, $input_file_url = null)
    {
        // verify the required parameter 'html_tag' is set
        if ($html_tag === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $html_tag when calling editHtmlHtmlAppendHeaderTag'
            );
        }

        $resourcePath = '/convert/edit/html/head/append/tag';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($html_tag !== null) {
            $headerParams['htmlTag'] = ObjectSerializer::toHeaderValue($html_tag);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlAppendHeading
     *
     * Append a Heading to an HTML Document
     *
     * @param  string $heading_text The text content to be used in the header. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  int $heading_size Optional: The heading size number. Default is 1. Accepts values between 1 and 6. (optional)
     * @param  string $css_style Optional: The CSS style for the heading. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlAppendHeading($heading_text, $input_file = null, $input_file_url = null, $heading_size = null, $css_style = null)
    {
        list($response) = $this->editHtmlHtmlAppendHeadingWithHttpInfo($heading_text, $input_file, $input_file_url, $heading_size, $css_style);
        return $response;
    }

    /**
     * Operation editHtmlHtmlAppendHeadingWithHttpInfo
     *
     * Append a Heading to an HTML Document
     *
     * @param  string $heading_text The text content to be used in the header. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  int $heading_size Optional: The heading size number. Default is 1. Accepts values between 1 and 6. (optional)
     * @param  string $css_style Optional: The CSS style for the heading. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlAppendHeadingWithHttpInfo($heading_text, $input_file = null, $input_file_url = null, $heading_size = null, $css_style = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendHeadingRequest($heading_text, $input_file, $input_file_url, $heading_size, $css_style);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlAppendHeadingAsync
     *
     * Append a Heading to an HTML Document
     *
     * @param  string $heading_text The text content to be used in the header. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  int $heading_size Optional: The heading size number. Default is 1. Accepts values between 1 and 6. (optional)
     * @param  string $css_style Optional: The CSS style for the heading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendHeadingAsync($heading_text, $input_file = null, $input_file_url = null, $heading_size = null, $css_style = null)
    {
        return $this->editHtmlHtmlAppendHeadingAsyncWithHttpInfo($heading_text, $input_file, $input_file_url, $heading_size, $css_style)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlAppendHeadingAsyncWithHttpInfo
     *
     * Append a Heading to an HTML Document
     *
     * @param  string $heading_text The text content to be used in the header. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  int $heading_size Optional: The heading size number. Default is 1. Accepts values between 1 and 6. (optional)
     * @param  string $css_style Optional: The CSS style for the heading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendHeadingAsyncWithHttpInfo($heading_text, $input_file = null, $input_file_url = null, $heading_size = null, $css_style = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendHeadingRequest($heading_text, $input_file, $input_file_url, $heading_size, $css_style);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlAppendHeading'
     *
     * @param  string $heading_text The text content to be used in the header. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  int $heading_size Optional: The heading size number. Default is 1. Accepts values between 1 and 6. (optional)
     * @param  string $css_style Optional: The CSS style for the heading. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlAppendHeadingRequest($heading_text, $input_file = null, $input_file_url = null, $heading_size = null, $css_style = null)
    {
        // verify the required parameter 'heading_text' is set
        if ($heading_text === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $heading_text when calling editHtmlHtmlAppendHeading'
            );
        }

        $resourcePath = '/convert/edit/html/append/heading';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($heading_text !== null) {
            $headerParams['headingText'] = ObjectSerializer::toHeaderValue($heading_text);
        }
        // header params
        if ($heading_size !== null) {
            $headerParams['headingSize'] = ObjectSerializer::toHeaderValue($heading_size);
        }
        // header params
        if ($css_style !== null) {
            $headerParams['cssStyle'] = ObjectSerializer::toHeaderValue($css_style);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlAppendImageFromUrl
     *
     * Append an Image to an HTML Document from a URL
     *
     * @param  string $image_url The URL for the image. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlAppendImageFromUrl($image_url, $input_file = null, $input_file_url = null, $css_style = null)
    {
        list($response) = $this->editHtmlHtmlAppendImageFromUrlWithHttpInfo($image_url, $input_file, $input_file_url, $css_style);
        return $response;
    }

    /**
     * Operation editHtmlHtmlAppendImageFromUrlWithHttpInfo
     *
     * Append an Image to an HTML Document from a URL
     *
     * @param  string $image_url The URL for the image. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlAppendImageFromUrlWithHttpInfo($image_url, $input_file = null, $input_file_url = null, $css_style = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendImageFromUrlRequest($image_url, $input_file, $input_file_url, $css_style);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlAppendImageFromUrlAsync
     *
     * Append an Image to an HTML Document from a URL
     *
     * @param  string $image_url The URL for the image. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendImageFromUrlAsync($image_url, $input_file = null, $input_file_url = null, $css_style = null)
    {
        return $this->editHtmlHtmlAppendImageFromUrlAsyncWithHttpInfo($image_url, $input_file, $input_file_url, $css_style)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlAppendImageFromUrlAsyncWithHttpInfo
     *
     * Append an Image to an HTML Document from a URL
     *
     * @param  string $image_url The URL for the image. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendImageFromUrlAsyncWithHttpInfo($image_url, $input_file = null, $input_file_url = null, $css_style = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendImageFromUrlRequest($image_url, $input_file, $input_file_url, $css_style);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlAppendImageFromUrl'
     *
     * @param  string $image_url The URL for the image. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlAppendImageFromUrlRequest($image_url, $input_file = null, $input_file_url = null, $css_style = null)
    {
        // verify the required parameter 'image_url' is set
        if ($image_url === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_url when calling editHtmlHtmlAppendImageFromUrl'
            );
        }

        $resourcePath = '/convert/edit/html/append/image/from-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($image_url !== null) {
            $headerParams['imageUrl'] = ObjectSerializer::toHeaderValue($image_url);
        }
        // header params
        if ($css_style !== null) {
            $headerParams['cssStyle'] = ObjectSerializer::toHeaderValue($css_style);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlAppendImageInline
     *
     * Append a Base64 Inline Image to an HTML Document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  \SplFileObject $image_file Optional: Image file to be appended as base64 inline image. (optional)
     * @param  string $image_url Optional: Image URL to be appended as base64 inline image. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     * @param  string $image_extension Optional: The extension (JPG, PNG, GIF, etc.) of the image file. Recommended if uploading an imageFile directly, instead of using imageUrl. If no extension can be determined, will default to JPG. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlAppendImageInline($input_file = null, $input_file_url = null, $image_file = null, $image_url = null, $css_style = null, $image_extension = null)
    {
        list($response) = $this->editHtmlHtmlAppendImageInlineWithHttpInfo($input_file, $input_file_url, $image_file, $image_url, $css_style, $image_extension);
        return $response;
    }

    /**
     * Operation editHtmlHtmlAppendImageInlineWithHttpInfo
     *
     * Append a Base64 Inline Image to an HTML Document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  \SplFileObject $image_file Optional: Image file to be appended as base64 inline image. (optional)
     * @param  string $image_url Optional: Image URL to be appended as base64 inline image. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     * @param  string $image_extension Optional: The extension (JPG, PNG, GIF, etc.) of the image file. Recommended if uploading an imageFile directly, instead of using imageUrl. If no extension can be determined, will default to JPG. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlAppendImageInlineWithHttpInfo($input_file = null, $input_file_url = null, $image_file = null, $image_url = null, $css_style = null, $image_extension = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendImageInlineRequest($input_file, $input_file_url, $image_file, $image_url, $css_style, $image_extension);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlAppendImageInlineAsync
     *
     * Append a Base64 Inline Image to an HTML Document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  \SplFileObject $image_file Optional: Image file to be appended as base64 inline image. (optional)
     * @param  string $image_url Optional: Image URL to be appended as base64 inline image. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     * @param  string $image_extension Optional: The extension (JPG, PNG, GIF, etc.) of the image file. Recommended if uploading an imageFile directly, instead of using imageUrl. If no extension can be determined, will default to JPG. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendImageInlineAsync($input_file = null, $input_file_url = null, $image_file = null, $image_url = null, $css_style = null, $image_extension = null)
    {
        return $this->editHtmlHtmlAppendImageInlineAsyncWithHttpInfo($input_file, $input_file_url, $image_file, $image_url, $css_style, $image_extension)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlAppendImageInlineAsyncWithHttpInfo
     *
     * Append a Base64 Inline Image to an HTML Document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  \SplFileObject $image_file Optional: Image file to be appended as base64 inline image. (optional)
     * @param  string $image_url Optional: Image URL to be appended as base64 inline image. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     * @param  string $image_extension Optional: The extension (JPG, PNG, GIF, etc.) of the image file. Recommended if uploading an imageFile directly, instead of using imageUrl. If no extension can be determined, will default to JPG. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendImageInlineAsyncWithHttpInfo($input_file = null, $input_file_url = null, $image_file = null, $image_url = null, $css_style = null, $image_extension = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendImageInlineRequest($input_file, $input_file_url, $image_file, $image_url, $css_style, $image_extension);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlAppendImageInline'
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  \SplFileObject $image_file Optional: Image file to be appended as base64 inline image. (optional)
     * @param  string $image_url Optional: Image URL to be appended as base64 inline image. (optional)
     * @param  string $css_style Optional: CSS style for the image. (optional)
     * @param  string $image_extension Optional: The extension (JPG, PNG, GIF, etc.) of the image file. Recommended if uploading an imageFile directly, instead of using imageUrl. If no extension can be determined, will default to JPG. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlAppendImageInlineRequest($input_file = null, $input_file_url = null, $image_file = null, $image_url = null, $css_style = null, $image_extension = null)
    {

        $resourcePath = '/convert/edit/html/append/image/inline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($image_url !== null) {
            $headerParams['imageUrl'] = ObjectSerializer::toHeaderValue($image_url);
        }
        // header params
        if ($css_style !== null) {
            $headerParams['cssStyle'] = ObjectSerializer::toHeaderValue($css_style);
        }
        // header params
        if ($image_extension !== null) {
            $headerParams['imageExtension'] = ObjectSerializer::toHeaderValue($image_extension);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // form params
        if ($image_file !== null) {
            $multipart = true;
            $formParams['imageFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($image_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlAppendParagraph
     *
     * Append a Paragraph to an HTML Document
     *
     * @param  string $paragraph_text The text content to be used in the paragraph. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: The CSS style for the paragraph. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlAppendParagraph($paragraph_text, $input_file = null, $input_file_url = null, $css_style = null)
    {
        list($response) = $this->editHtmlHtmlAppendParagraphWithHttpInfo($paragraph_text, $input_file, $input_file_url, $css_style);
        return $response;
    }

    /**
     * Operation editHtmlHtmlAppendParagraphWithHttpInfo
     *
     * Append a Paragraph to an HTML Document
     *
     * @param  string $paragraph_text The text content to be used in the paragraph. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: The CSS style for the paragraph. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlAppendParagraphWithHttpInfo($paragraph_text, $input_file = null, $input_file_url = null, $css_style = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendParagraphRequest($paragraph_text, $input_file, $input_file_url, $css_style);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlAppendParagraphAsync
     *
     * Append a Paragraph to an HTML Document
     *
     * @param  string $paragraph_text The text content to be used in the paragraph. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: The CSS style for the paragraph. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendParagraphAsync($paragraph_text, $input_file = null, $input_file_url = null, $css_style = null)
    {
        return $this->editHtmlHtmlAppendParagraphAsyncWithHttpInfo($paragraph_text, $input_file, $input_file_url, $css_style)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlAppendParagraphAsyncWithHttpInfo
     *
     * Append a Paragraph to an HTML Document
     *
     * @param  string $paragraph_text The text content to be used in the paragraph. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: The CSS style for the paragraph. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlAppendParagraphAsyncWithHttpInfo($paragraph_text, $input_file = null, $input_file_url = null, $css_style = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlAppendParagraphRequest($paragraph_text, $input_file, $input_file_url, $css_style);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlAppendParagraph'
     *
     * @param  string $paragraph_text The text content to be used in the paragraph. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $css_style Optional: The CSS style for the paragraph. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlAppendParagraphRequest($paragraph_text, $input_file = null, $input_file_url = null, $css_style = null)
    {
        // verify the required parameter 'paragraph_text' is set
        if ($paragraph_text === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $paragraph_text when calling editHtmlHtmlAppendParagraph'
            );
        }

        $resourcePath = '/convert/edit/html/append/paragraph';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($paragraph_text !== null) {
            $headerParams['paragraphText'] = ObjectSerializer::toHeaderValue($paragraph_text);
        }
        // header params
        if ($css_style !== null) {
            $headerParams['cssStyle'] = ObjectSerializer::toHeaderValue($css_style);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlCreateBlankDocument
     *
     * Create a Blank HTML Document
     *
     * @param  string $title Optional: The title of the HTML document (optional)
     * @param  string $css_url Optional: A CSS style URL to be added to the document. (optional)
     * @param  string $css_inline Optional: An inline CSS style to be added to the document. (optional)
     * @param  string $javascript_url Optional: Javascript URL to be added to the document. (optional)
     * @param  string $javascript_inline Optional: Inline Javascript to be added to the document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlCreateBlankDocument($title = null, $css_url = null, $css_inline = null, $javascript_url = null, $javascript_inline = null)
    {
        list($response) = $this->editHtmlHtmlCreateBlankDocumentWithHttpInfo($title, $css_url, $css_inline, $javascript_url, $javascript_inline);
        return $response;
    }

    /**
     * Operation editHtmlHtmlCreateBlankDocumentWithHttpInfo
     *
     * Create a Blank HTML Document
     *
     * @param  string $title Optional: The title of the HTML document (optional)
     * @param  string $css_url Optional: A CSS style URL to be added to the document. (optional)
     * @param  string $css_inline Optional: An inline CSS style to be added to the document. (optional)
     * @param  string $javascript_url Optional: Javascript URL to be added to the document. (optional)
     * @param  string $javascript_inline Optional: Inline Javascript to be added to the document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlCreateBlankDocumentWithHttpInfo($title = null, $css_url = null, $css_inline = null, $javascript_url = null, $javascript_inline = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlCreateBlankDocumentRequest($title, $css_url, $css_inline, $javascript_url, $javascript_inline);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlCreateBlankDocumentAsync
     *
     * Create a Blank HTML Document
     *
     * @param  string $title Optional: The title of the HTML document (optional)
     * @param  string $css_url Optional: A CSS style URL to be added to the document. (optional)
     * @param  string $css_inline Optional: An inline CSS style to be added to the document. (optional)
     * @param  string $javascript_url Optional: Javascript URL to be added to the document. (optional)
     * @param  string $javascript_inline Optional: Inline Javascript to be added to the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlCreateBlankDocumentAsync($title = null, $css_url = null, $css_inline = null, $javascript_url = null, $javascript_inline = null)
    {
        return $this->editHtmlHtmlCreateBlankDocumentAsyncWithHttpInfo($title, $css_url, $css_inline, $javascript_url, $javascript_inline)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlCreateBlankDocumentAsyncWithHttpInfo
     *
     * Create a Blank HTML Document
     *
     * @param  string $title Optional: The title of the HTML document (optional)
     * @param  string $css_url Optional: A CSS style URL to be added to the document. (optional)
     * @param  string $css_inline Optional: An inline CSS style to be added to the document. (optional)
     * @param  string $javascript_url Optional: Javascript URL to be added to the document. (optional)
     * @param  string $javascript_inline Optional: Inline Javascript to be added to the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlCreateBlankDocumentAsyncWithHttpInfo($title = null, $css_url = null, $css_inline = null, $javascript_url = null, $javascript_inline = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlCreateBlankDocumentRequest($title, $css_url, $css_inline, $javascript_url, $javascript_inline);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlCreateBlankDocument'
     *
     * @param  string $title Optional: The title of the HTML document (optional)
     * @param  string $css_url Optional: A CSS style URL to be added to the document. (optional)
     * @param  string $css_inline Optional: An inline CSS style to be added to the document. (optional)
     * @param  string $javascript_url Optional: Javascript URL to be added to the document. (optional)
     * @param  string $javascript_inline Optional: Inline Javascript to be added to the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlCreateBlankDocumentRequest($title = null, $css_url = null, $css_inline = null, $javascript_url = null, $javascript_inline = null)
    {

        $resourcePath = '/convert/edit/html/create/blank';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($title !== null) {
            $headerParams['title'] = ObjectSerializer::toHeaderValue($title);
        }
        // header params
        if ($css_url !== null) {
            $headerParams['cssUrl'] = ObjectSerializer::toHeaderValue($css_url);
        }
        // header params
        if ($css_inline !== null) {
            $headerParams['cssInline'] = ObjectSerializer::toHeaderValue($css_inline);
        }
        // header params
        if ($javascript_url !== null) {
            $headerParams['javascriptUrl'] = ObjectSerializer::toHeaderValue($javascript_url);
        }
        // header params
        if ($javascript_inline !== null) {
            $headerParams['javascriptInline'] = ObjectSerializer::toHeaderValue($javascript_inline);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlGetLanguage
     *
     * Gets the language for the HTML document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HtmlGetLanguageResult
     */
    public function editHtmlHtmlGetLanguage($input_file = null, $input_file_url = null)
    {
        list($response) = $this->editHtmlHtmlGetLanguageWithHttpInfo($input_file, $input_file_url);
        return $response;
    }

    /**
     * Operation editHtmlHtmlGetLanguageWithHttpInfo
     *
     * Gets the language for the HTML document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HtmlGetLanguageResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlGetLanguageWithHttpInfo($input_file = null, $input_file_url = null)
    {
        $returnType = '\Swagger\Client\Model\HtmlGetLanguageResult';
        $request = $this->editHtmlHtmlGetLanguageRequest($input_file, $input_file_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HtmlGetLanguageResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlGetLanguageAsync
     *
     * Gets the language for the HTML document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlGetLanguageAsync($input_file = null, $input_file_url = null)
    {
        return $this->editHtmlHtmlGetLanguageAsyncWithHttpInfo($input_file, $input_file_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlGetLanguageAsyncWithHttpInfo
     *
     * Gets the language for the HTML document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlGetLanguageAsyncWithHttpInfo($input_file = null, $input_file_url = null)
    {
        $returnType = '\Swagger\Client\Model\HtmlGetLanguageResult';
        $request = $this->editHtmlHtmlGetLanguageRequest($input_file, $input_file_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlGetLanguage'
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlGetLanguageRequest($input_file = null, $input_file_url = null)
    {

        $resourcePath = '/convert/edit/html/head/get/language';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlGetLinks
     *
     * Extract resolved link URLs from HTML File
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $base_url Optional: Base URL of the page, such as https://mydomain.com (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HtmlGetLinksResponse
     */
    public function editHtmlHtmlGetLinks($input_file = null, $input_file_url = null, $base_url = null)
    {
        list($response) = $this->editHtmlHtmlGetLinksWithHttpInfo($input_file, $input_file_url, $base_url);
        return $response;
    }

    /**
     * Operation editHtmlHtmlGetLinksWithHttpInfo
     *
     * Extract resolved link URLs from HTML File
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $base_url Optional: Base URL of the page, such as https://mydomain.com (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HtmlGetLinksResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlGetLinksWithHttpInfo($input_file = null, $input_file_url = null, $base_url = null)
    {
        $returnType = '\Swagger\Client\Model\HtmlGetLinksResponse';
        $request = $this->editHtmlHtmlGetLinksRequest($input_file, $input_file_url, $base_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HtmlGetLinksResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlGetLinksAsync
     *
     * Extract resolved link URLs from HTML File
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $base_url Optional: Base URL of the page, such as https://mydomain.com (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlGetLinksAsync($input_file = null, $input_file_url = null, $base_url = null)
    {
        return $this->editHtmlHtmlGetLinksAsyncWithHttpInfo($input_file, $input_file_url, $base_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlGetLinksAsyncWithHttpInfo
     *
     * Extract resolved link URLs from HTML File
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $base_url Optional: Base URL of the page, such as https://mydomain.com (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlGetLinksAsyncWithHttpInfo($input_file = null, $input_file_url = null, $base_url = null)
    {
        $returnType = '\Swagger\Client\Model\HtmlGetLinksResponse';
        $request = $this->editHtmlHtmlGetLinksRequest($input_file, $input_file_url, $base_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlGetLinks'
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     * @param  string $base_url Optional: Base URL of the page, such as https://mydomain.com (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlGetLinksRequest($input_file = null, $input_file_url = null, $base_url = null)
    {

        $resourcePath = '/convert/edit/html/extract/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($base_url !== null) {
            $headerParams['baseUrl'] = ObjectSerializer::toHeaderValue($base_url);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlGetRelCanonical
     *
     * Gets the rel canonical URL for the HTML document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HtmlGetRelCanonicalUrlResult
     */
    public function editHtmlHtmlGetRelCanonical($input_file = null, $input_file_url = null)
    {
        list($response) = $this->editHtmlHtmlGetRelCanonicalWithHttpInfo($input_file, $input_file_url);
        return $response;
    }

    /**
     * Operation editHtmlHtmlGetRelCanonicalWithHttpInfo
     *
     * Gets the rel canonical URL for the HTML document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HtmlGetRelCanonicalUrlResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlGetRelCanonicalWithHttpInfo($input_file = null, $input_file_url = null)
    {
        $returnType = '\Swagger\Client\Model\HtmlGetRelCanonicalUrlResult';
        $request = $this->editHtmlHtmlGetRelCanonicalRequest($input_file, $input_file_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HtmlGetRelCanonicalUrlResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlGetRelCanonicalAsync
     *
     * Gets the rel canonical URL for the HTML document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlGetRelCanonicalAsync($input_file = null, $input_file_url = null)
    {
        return $this->editHtmlHtmlGetRelCanonicalAsyncWithHttpInfo($input_file, $input_file_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlGetRelCanonicalAsyncWithHttpInfo
     *
     * Gets the rel canonical URL for the HTML document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlGetRelCanonicalAsyncWithHttpInfo($input_file = null, $input_file_url = null)
    {
        $returnType = '\Swagger\Client\Model\HtmlGetRelCanonicalUrlResult';
        $request = $this->editHtmlHtmlGetRelCanonicalRequest($input_file, $input_file_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlGetRelCanonical'
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlGetRelCanonicalRequest($input_file = null, $input_file_url = null)
    {

        $resourcePath = '/convert/edit/html/head/get/rel-canonical-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlGetSitemap
     *
     * Gets the sitemap URL for the HTML document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HtmlGetSitemapUrlResult
     */
    public function editHtmlHtmlGetSitemap($input_file = null, $input_file_url = null)
    {
        list($response) = $this->editHtmlHtmlGetSitemapWithHttpInfo($input_file, $input_file_url);
        return $response;
    }

    /**
     * Operation editHtmlHtmlGetSitemapWithHttpInfo
     *
     * Gets the sitemap URL for the HTML document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HtmlGetSitemapUrlResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlGetSitemapWithHttpInfo($input_file = null, $input_file_url = null)
    {
        $returnType = '\Swagger\Client\Model\HtmlGetSitemapUrlResult';
        $request = $this->editHtmlHtmlGetSitemapRequest($input_file, $input_file_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HtmlGetSitemapUrlResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlGetSitemapAsync
     *
     * Gets the sitemap URL for the HTML document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlGetSitemapAsync($input_file = null, $input_file_url = null)
    {
        return $this->editHtmlHtmlGetSitemapAsyncWithHttpInfo($input_file, $input_file_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlGetSitemapAsyncWithHttpInfo
     *
     * Gets the sitemap URL for the HTML document
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlGetSitemapAsyncWithHttpInfo($input_file = null, $input_file_url = null)
    {
        $returnType = '\Swagger\Client\Model\HtmlGetSitemapUrlResult';
        $request = $this->editHtmlHtmlGetSitemapRequest($input_file, $input_file_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlGetSitemap'
     *
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlGetSitemapRequest($input_file = null, $input_file_url = null)
    {

        $resourcePath = '/convert/edit/html/head/get/sitemap-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlSetLanguage
     *
     * Sets the language for the HTML document
     *
     * @param  string $language_code The HTML langauge code to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlSetLanguage($language_code, $input_file = null, $input_file_url = null)
    {
        list($response) = $this->editHtmlHtmlSetLanguageWithHttpInfo($language_code, $input_file, $input_file_url);
        return $response;
    }

    /**
     * Operation editHtmlHtmlSetLanguageWithHttpInfo
     *
     * Sets the language for the HTML document
     *
     * @param  string $language_code The HTML langauge code to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlSetLanguageWithHttpInfo($language_code, $input_file = null, $input_file_url = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlSetLanguageRequest($language_code, $input_file, $input_file_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlSetLanguageAsync
     *
     * Sets the language for the HTML document
     *
     * @param  string $language_code The HTML langauge code to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlSetLanguageAsync($language_code, $input_file = null, $input_file_url = null)
    {
        return $this->editHtmlHtmlSetLanguageAsyncWithHttpInfo($language_code, $input_file, $input_file_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlSetLanguageAsyncWithHttpInfo
     *
     * Sets the language for the HTML document
     *
     * @param  string $language_code The HTML langauge code to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlSetLanguageAsyncWithHttpInfo($language_code, $input_file = null, $input_file_url = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlSetLanguageRequest($language_code, $input_file, $input_file_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlSetLanguage'
     *
     * @param  string $language_code The HTML langauge code to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlSetLanguageRequest($language_code, $input_file = null, $input_file_url = null)
    {
        // verify the required parameter 'language_code' is set
        if ($language_code === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language_code when calling editHtmlHtmlSetLanguage'
            );
        }

        $resourcePath = '/convert/edit/html/head/set/language';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($language_code !== null) {
            $headerParams['languageCode'] = ObjectSerializer::toHeaderValue($language_code);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlSetRelCanonical
     *
     * Sets the rel canonical URL for the HTML document
     *
     * @param  string $canonical_url The HTML canonical URL to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlSetRelCanonical($canonical_url, $input_file = null, $input_file_url = null)
    {
        list($response) = $this->editHtmlHtmlSetRelCanonicalWithHttpInfo($canonical_url, $input_file, $input_file_url);
        return $response;
    }

    /**
     * Operation editHtmlHtmlSetRelCanonicalWithHttpInfo
     *
     * Sets the rel canonical URL for the HTML document
     *
     * @param  string $canonical_url The HTML canonical URL to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlSetRelCanonicalWithHttpInfo($canonical_url, $input_file = null, $input_file_url = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlSetRelCanonicalRequest($canonical_url, $input_file, $input_file_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlSetRelCanonicalAsync
     *
     * Sets the rel canonical URL for the HTML document
     *
     * @param  string $canonical_url The HTML canonical URL to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlSetRelCanonicalAsync($canonical_url, $input_file = null, $input_file_url = null)
    {
        return $this->editHtmlHtmlSetRelCanonicalAsyncWithHttpInfo($canonical_url, $input_file, $input_file_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlSetRelCanonicalAsyncWithHttpInfo
     *
     * Sets the rel canonical URL for the HTML document
     *
     * @param  string $canonical_url The HTML canonical URL to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlSetRelCanonicalAsyncWithHttpInfo($canonical_url, $input_file = null, $input_file_url = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlSetRelCanonicalRequest($canonical_url, $input_file, $input_file_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlSetRelCanonical'
     *
     * @param  string $canonical_url The HTML canonical URL to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlSetRelCanonicalRequest($canonical_url, $input_file = null, $input_file_url = null)
    {
        // verify the required parameter 'canonical_url' is set
        if ($canonical_url === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $canonical_url when calling editHtmlHtmlSetRelCanonical'
            );
        }

        $resourcePath = '/convert/edit/html/head/set/rel-canonical-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($canonical_url !== null) {
            $headerParams['canonicalUrl'] = ObjectSerializer::toHeaderValue($canonical_url);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editHtmlHtmlSetSitemapUrl
     *
     * Sets the sitemap URL for the HTML document
     *
     * @param  string $sitemap_url The HTML sitemap URL to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function editHtmlHtmlSetSitemapUrl($sitemap_url, $input_file = null, $input_file_url = null)
    {
        list($response) = $this->editHtmlHtmlSetSitemapUrlWithHttpInfo($sitemap_url, $input_file, $input_file_url);
        return $response;
    }

    /**
     * Operation editHtmlHtmlSetSitemapUrlWithHttpInfo
     *
     * Sets the sitemap URL for the HTML document
     *
     * @param  string $sitemap_url The HTML sitemap URL to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function editHtmlHtmlSetSitemapUrlWithHttpInfo($sitemap_url, $input_file = null, $input_file_url = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlSetSitemapUrlRequest($sitemap_url, $input_file, $input_file_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation editHtmlHtmlSetSitemapUrlAsync
     *
     * Sets the sitemap URL for the HTML document
     *
     * @param  string $sitemap_url The HTML sitemap URL to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlSetSitemapUrlAsync($sitemap_url, $input_file = null, $input_file_url = null)
    {
        return $this->editHtmlHtmlSetSitemapUrlAsyncWithHttpInfo($sitemap_url, $input_file, $input_file_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editHtmlHtmlSetSitemapUrlAsyncWithHttpInfo
     *
     * Sets the sitemap URL for the HTML document
     *
     * @param  string $sitemap_url The HTML sitemap URL to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editHtmlHtmlSetSitemapUrlAsyncWithHttpInfo($sitemap_url, $input_file = null, $input_file_url = null)
    {
        $returnType = 'string';
        $request = $this->editHtmlHtmlSetSitemapUrlRequest($sitemap_url, $input_file, $input_file_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editHtmlHtmlSetSitemapUrl'
     *
     * @param  string $sitemap_url The HTML sitemap URL to set. (required)
     * @param  \SplFileObject $input_file Optional: Input file to perform the operation on. (optional)
     * @param  string $input_file_url Optional: URL of a file to operate on as input. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function editHtmlHtmlSetSitemapUrlRequest($sitemap_url, $input_file = null, $input_file_url = null)
    {
        // verify the required parameter 'sitemap_url' is set
        if ($sitemap_url === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sitemap_url when calling editHtmlHtmlSetSitemapUrl'
            );
        }

        $resourcePath = '/convert/edit/html/head/set/sitemap-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($input_file_url !== null) {
            $headerParams['inputFileUrl'] = ObjectSerializer::toHeaderValue($input_file_url);
        }
        // header params
        if ($sitemap_url !== null) {
            $headerParams['sitemapUrl'] = ObjectSerializer::toHeaderValue($sitemap_url);
        }


        // form params
        if ($input_file !== null) {
            $multipart = true;
            $formParams['inputFile'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($input_file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Apikey');
        if ($apiKey !== null) {
            $headers['Apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
